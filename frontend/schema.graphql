schema {
  query: Query
  mutation: Mutation
}

"""
The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response.
"""
directive @cost(
  """
  The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc.
  """
  weight: String!
) on ARGUMENT_DEFINITION | ENUM | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | OBJECT | SCALAR

type AccountType {
  createdAt: DateTime!
  email: String!
  id: Int!
  updatedAt: DateTime
}

"""Defines when a policy shall be executed."""
enum ApplyPolicy {
  """After the resolver was executed."""
  AFTER_RESOLVER
  """Before the resolver was executed."""
  BEFORE_RESOLVER
  """The policy is applied in the validation step before the execution."""
  VALIDATION
}

type AuthPayload {
  account: AccountType!
  token: String!
}

input ConfigurationInput {
  accountId: Int!
  id: Int!
  ruleName: String!
  ruleValues: [RuleValueInput!]
}

type ConfigurationType {
  accountId: Int!
  id: Int!
  ruleName: String!
  ruleValues: [RuleValue!]
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

type Mutation {
  createAccount(email: String!, password: String!): AccountType!
  createConfiguration(input: ConfigurationInput!): ConfigurationType!
  login(email: String!, password: String!): AuthPayload!
  loginAccount(email: String!, password: String!): AccountType
  updateConfiguration(input: ConfigurationInput!): ConfigurationType!
}

type Query {
  accountByEmail(email: String!): AccountType
  accounts: [AccountType!]!
  configurationById(id: Int!): ConfigurationType
  configurations: [ConfigurationType!]!
  isAValidJwt: Boolean!
}

type RuleValue {
  configurationId: Int!
  id: Int!
  name: String!
  value: Int!
}

input RuleValueInput {
  configurationId: Int!
  id: Int!
  name: String!
  value: Int!
}