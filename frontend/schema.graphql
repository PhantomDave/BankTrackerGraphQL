schema {
  query: Query
  mutation: Mutation
}

type AccountType {
  id: Int!
  email: String!
  currentBalance: Decimal
  createdAt: DateTime!
  updatedAt: DateTime
}

type AuthPayload {
  token: String!
  account: AccountType!
}

type ColumnDetectionResult {
  column: String!
  suggestedMapping: String!
  confidence: Int!
}

type FinanceRecordType {
  id: Int!
  name: String!
  amount: Decimal!
  currency: String!
  description: String!
  date: DateTime!
  isRecurring: Boolean!
  recurrenceFrequency: RecurrenceFrequency!
  recurrenceEndDate: DateTime
  lastProcessedDate: DateTime
  parentRecurringRecordId: Int
  isRecurringInstance: Boolean!
}

type ImportError {
  rowNumber: Int!
  message: String!
  rowData: [KeyValuePairOfStringAndString!]!
}

type ImportPreviewType {
  detectedColumns: [KeyValuePairOfStringAndColumnDetectionResult!]!
  sampleRows: [[KeyValuePairOfStringAndString!]!]!
  totalRows: Int!
  headers: [String!]!
}

type ImportResultType {
  successCount: Int!
  failureCount: Int!
  duplicateCount: Int!
  errors: [ImportError!]!
  createdRecords: [FinanceRecordType!]!
}

type KeyValuePairOfStringAndColumnDetectionResult {
  key: String!
  value: ColumnDetectionResult!
}

type KeyValuePairOfStringAndString {
  key: String!
  value: String!
}

type Mutation {
  createAccount(email: String! password: String!): AccountType! @allowAnonymous @cost(weight: "10")
  loginAccount(email: String! password: String!): AccountType @allowAnonymous @cost(weight: "10")
  login(email: String! password: String!): AuthPayload! @allowAnonymous @cost(weight: "10")
  updateAccount(email: String! currentBalance: Decimal): AccountType! @cost(weight: "10")
  createFinanceRecord(newRecord: FinanceRecordInput!): FinanceRecordType! @authorize @cost(weight: "10")
  updateFinanceRecord(id: Int! amount: Decimal currency: String description: String date: DateTime isRecurring: Boolean name: String recurrenceFrequency: RecurrenceFrequency recurrenceEndDate: DateTime): FinanceRecordType! @authorize @cost(weight: "10")
  deleteFinanceRecord(id: Int!): Boolean! @authorize @cost(weight: "10")
  previewImport(input: PreviewImportInput!): ImportPreviewType! @authorize @cost(weight: "10")
  confirmImport(input: ConfirmImportInput!): ImportResultType! @authorize @cost(weight: "10")
}

type Query {
  accounts: [AccountType!]! @authorize @cost(weight: "10")
  accountByEmail(email: String!): AccountType @authorize @cost(weight: "10")
  userAccount: AccountType @authorize @cost(weight: "10")
  isAValidJwt: Boolean! @authorize @cost(weight: "10")
  financeRecordsForAccount(startDate: DateTime endDate: DateTime): [FinanceRecordType!]! @authorize @cost(weight: "10")
  financeRecord(id: Int!): FinanceRecordType @authorize @cost(weight: "10")
}

input ConfirmImportInput {
  file: Upload!
  columnMappings: [KeyValuePairOfStringAndStringInput!]!
  dateFormat: String!
  decimalSeparator: String!
  thousandsSeparator: String!
  rowsToSkip: Int!
  saveAsTemplate: Boolean!
  templateName: String
}

input FinanceRecordInput {
  id: Int
  name: String!
  amount: Decimal!
  currency: String!
  description: String
  date: DateTime
  isRecurring: Boolean!
  recurrenceFrequency: RecurrenceFrequency
  recurrenceEndDate: DateTime
}

input KeyValuePairOfStringAndStringInput {
  key: String!
  value: String!
}

input PreviewImportInput {
  file: Upload!
  templateId: Int
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

enum RecurrenceFrequency {
  NONE
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

directive @allowAnonymous repeatable on FIELD_DEFINITION

"The authorize directive."
directive @authorize("The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!] "Defines when when the authorize directive shall be applied.By default the authorize directives are applied during the validation phase." apply: ApplyPolicy! = BEFORE_RESOLVER) repeatable on OBJECT | FIELD_DEFINITION

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Decimal` scalar type represents a decimal floating-point number."
scalar Decimal

"The `Upload` scalar type represents a file upload."
scalar Upload