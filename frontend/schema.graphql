schema {
  query: Query
  mutation: Mutation
}

"""
The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response.
"""
directive @cost(
  """
  The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc.
  """
  weight: String!
) on ARGUMENT_DEFINITION | ENUM | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | OBJECT | SCALAR

type AccountType {
  createdAt: DateTime!
  currentBalance: Decimal
  email: String!
  id: Int!
  updatedAt: DateTime
}

"""Defines when a policy shall be executed."""
enum ApplyPolicy {
  """After the resolver was executed."""
  AFTER_RESOLVER
  """Before the resolver was executed."""
  BEFORE_RESOLVER
  """The policy is applied in the validation step before the execution."""
  VALIDATION
}

type AuthPayload {
  account: AccountType!
  token: String!
}

type ColumnDetectionResult {
  column: String!
  confidence: Int!
  suggestedMapping: String!
}

input ConfirmImportInput {
  columnMappings: [KeyValuePairOfStringAndStringInput!]!
  dateFormat: String!
  decimalSeparator: String!
  file: Upload!
  rowsToSkip: Int!
  saveAsTemplate: Boolean!
  templateName: String
  thousandsSeparator: String!
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

"""The `Decimal` scalar type represents a decimal floating-point number."""
scalar Decimal

input FinanceRecordInput {
  amount: Decimal!
  currency: String!
  date: DateTime
  description: String
  id: Int
  isRecurring: Boolean!
  name: String!
  recurrenceEndDate: DateTime
  recurrenceFrequency: RecurrenceFrequency
}

type FinanceRecordType {
  amount: Decimal!
  currency: String!
  date: DateTime!
  description: String!
  id: Int!
  isRecurring: Boolean!
  isRecurringInstance: Boolean!
  lastProcessedDate: DateTime
  name: String!
  parentRecurringRecordId: Int
  recurrenceEndDate: DateTime
  recurrenceFrequency: RecurrenceFrequency!
}

type ImportError {
  message: String!
  rowData: [KeyValuePairOfStringAndString!]!
  rowNumber: Int!
}

type ImportPreviewType {
  detectedColumns: [KeyValuePairOfStringAndColumnDetectionResult!]!
  headers: [String!]!
  sampleRows: [[KeyValuePairOfStringAndString!]!]!
  totalRows: Int!
}

type ImportResultType {
  createdRecords: [FinanceRecordType!]!
  duplicateCount: Int!
  errors: [ImportError!]!
  failureCount: Int!
  successCount: Int!
}

type KeyValuePairOfStringAndColumnDetectionResult {
  key: String!
  value: ColumnDetectionResult!
}

type KeyValuePairOfStringAndString {
  key: String!
  value: String!
}

input KeyValuePairOfStringAndStringInput {
  key: String!
  value: String!
}

type Mutation {
  confirmImport(input: ConfirmImportInput!): ImportResultType!
  createAccount(email: String!, password: String!): AccountType!
  createFinanceRecord(newRecord: FinanceRecordInput!): FinanceRecordType!
  deleteFinanceRecord(id: Int!): Boolean!
  login(email: String!, password: String!): AuthPayload!
  loginAccount(email: String!, password: String!): AccountType
  previewImport(input: PreviewImportInput!): ImportPreviewType!
  updateAccount(currentBalance: Decimal, email: String!): AccountType!
  updateFinanceRecord(amount: Decimal, currency: String, date: DateTime, description: String, id: Int!, isRecurring: Boolean, name: String, recurrenceEndDate: DateTime, recurrenceFrequency: RecurrenceFrequency): FinanceRecordType!
}

input PreviewImportInput {
  file: Upload!
  templateId: Int
}

type Query {
  accountByEmail(email: String!): AccountType
  accounts: [AccountType!]!
  financeRecord(id: Int!): FinanceRecordType
  financeRecordsForAccount(endDate: DateTime, startDate: DateTime): [FinanceRecordType!]!
  isAValidJwt: Boolean!
  userAccount: AccountType
}

enum RecurrenceFrequency {
  DAILY
  MONTHLY
  NONE
  WEEKLY
  YEARLY
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload